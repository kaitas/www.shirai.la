<?xml version="1.0" encoding="UTF-8"?><rss version="2.0"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:atom="http://www.w3.org/2005/Atom"
	xmlns:sy="http://purl.org/rss/1.0/modules/syndication/"
	xmlns:slash="http://purl.org/rss/1.0/modules/slash/"
	>

<channel>
	<title>s1323133 &#8211; 白井セミナー 2015前期</title>
	<atom:link href="http://blog.shirai.la/semi2015a/author/s1323133/feed/" rel="self" type="application/rss+xml" />
	<link>http://blog.shirai.la/semi2015a</link>
	<description>神奈川工科大学 情報メディア学科 3年次 専門ユニット演習サイトです</description>
	<lastBuildDate>
	Wed, 28 Feb 2018 23:24:58 +0000	</lastBuildDate>
	<language>ja</language>
	<sy:updatePeriod>
	hourly	</sy:updatePeriod>
	<sy:updateFrequency>
	1	</sy:updateFrequency>
	<generator>https://wordpress.org/?v=5.1.6</generator>
	<item>
		<title>私が白井研究室セミナーを通して学んだこと（齊藤弘朗）</title>
		<link>http://blog.shirai.la/semi2015a/2015_0801/</link>
				<pubDate>Mon, 03 Aug 2015 11:25:43 +0000</pubDate>
		<dc:creator><![CDATA[s1323133]]></dc:creator>
				<category><![CDATA[セミナー]]></category>
		<category><![CDATA[最終課題]]></category>
		<category><![CDATA[1323133]]></category>

		<guid isPermaLink="false">http://blog.shirai.la/semi2015a/?p=673</guid>
				<description><![CDATA[こんにちは、神奈川工科大学情報学部情報メディア学科 学籍番号1323133の齊藤弘朗です。 今回は私は前期セミ &#8230; <a href="http://blog.shirai.la/semi2015a/2015_0801/" class="more-link">続きを読む <span class="screen-reader-text">私が白井研究室セミナーを通して学んだこと（齊藤弘朗）</span></a>]]></description>
								<content:encoded><![CDATA[<p><a href="http://blog.shirai.la/semi2015a/files/2015/08/11805922_436792039838865_1059627164_n.jpg"><img class="alignnone  wp-image-711" src="http://blog.shirai.la/semi2015a/files/2015/08/11805922_436792039838865_1059627164_n-300x225.jpg" alt="11805922_436792039838865_1059627164_n" width="365" height="274" srcset="http://blog.shirai.la/semi2015a/files/2015/08/11805922_436792039838865_1059627164_n-300x225.jpg 300w, http://blog.shirai.la/semi2015a/files/2015/08/11805922_436792039838865_1059627164_n.jpg 960w" sizes="(max-width: 365px) 100vw, 365px" /></a></p>
<p>こんにちは、神奈川工科大学情報学部情報メディア学科<br />
学籍番号1323133の齊藤弘朗です。<br />
今回は私は前期セミナー配属で白井研究室セミナーに配属されました。先日で最後の講義が終了しましたので私が白井研究室セミナーで行ったこととそこから学んだことを書いて行きたいと考えています。私が白井研究室で行った主なことは2つあります。</p>
<p>1つ目にIVRCの企画書と企画概要の制作と提出</p>
<p>2つ目に自分のやりたいことであるオンラインゲームについての<br />
本を読み知識を深める</p>
<p>以上の2つのことです。</p>
<p>まず一つ目に1つ目のIVRCについてです。</p>
<p>まずIVRCとは正式名称は国際学生対抗バーチャルリアリティコンテストと言い、学生が企画・制作した作品を作品の新規性、技術的チャレンジ、体験のインパクトを競うコンテストです。このコンテストは1993年から開催されています。</p>
<p>まず私たちがIVRCに提出する企画書を作るためにしたことは各自別々の年度の過去作品を調べ過去のどのような作品が存在していたのかと言うことを調べました。<br />
これを行うことで過去にあった作品との差別化を行いました。</p>
<p>次にどのような作品を作るかの意見を出し合ってそこから各自チームに分かれての制作になりました。<br />
チームでの作業も最初はどのような形で意見を実装するのかと言う点とその技術は過去の作品で使われていないのかということと、技術的な挑戦があるのかと言うことを考えていきました。そうやって意見を詰めていき企画書を作り上げていきました。<br />
はじめはわからない事だらけで何からどうはじめていけばよいかわからなかったり、チーム内での連絡がうまく取れずなかなかうまく進みませんでしたが、先生や先輩方、他のチームの人たちに添削やレビューを行ってもらったり最後はお互いうまく協力し合うことによって企画書を無事に仕上げることができました。</p>
<p>最終的に提出した企画は通りませんでしたが。<br />
私はこの企画書を作ることにとってチームで動く際の連絡の重要性と、過去の作品を調査して同じような作品があってもそれとの差別化をすることと、過去の作品から発想を得ることの大切さを学ぶことができたと感じています。</p>
<p>以下に実際に仕上げた企画概要の画像です。</p>
<p>&nbsp;</p>
<p><a href="http://blog.shirai.la/semi2015a/files/2015/07/企画概要.png"><img class="alignnone size-medium wp-image-674" src="http://blog.shirai.la/semi2015a/files/2015/07/企画概要-300x274.png" alt="企画概要" width="300" height="274" srcset="http://blog.shirai.la/semi2015a/files/2015/07/企画概要-300x274.png 300w, http://blog.shirai.la/semi2015a/files/2015/07/企画概要.png 921w" sizes="(max-width: 300px) 100vw, 300px" /></a></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>次に自分のやりたいこととして、私はオンラインゲームに対する理解を深めるということを行いました。<br />
このとき使った資料はオンラインゲームのしくみ<br />
Unityで覚えるネトワークプログラミングという本を参考にして行いました。</p>
<p>はじめただオンラインにするだけと甘く見ていましたが実際に読み進めて行くと接続と切断や相手との通信のタイミングなど考えることが多く予想以上に大変でした。</p>
<p>しかしこのオンラインゲームのしくみと言う本ではサンプルをネットで配布しているので簡単に実行結果を見ることができます。なのでそのサンプルを実行しながら本に書いてある解説を読んでい少しずつでしたが理解することができました。</p>
<p>オンラインゲームについて何も知らない自分がネットワークプログラミングについて理解を深めるための取っ掛かりを作るための資料としてとてもわかりやすい教材であったと感じています。</p>
<p>これからは、まだ全てのサンプルを理解することができていないのでその理解と自身で一つ作品を作ることを目標としていきたいと考えています。</p>
<p>ここからは白井研究室セミナー全体を通して学んだことを書いて行きたいと思います。<br />
はじめに自身の情報を発信することの重要性を学びそこからブログの書き方を学びました。　ＩＶＲＣでは企画書の書き方やチームで動くことの難しさや楽しさを学ぶことができたと感じています。<br />
ＩＶＲ展に行くことで今どのような技術が使われているのか最先端の技術の一端を見ることができとても貴重な体験であったと感じています。<br />
最後に行った自分のやりたいことでは、自分で目標を設定しそこから行動を起こしていくということをしなくてはいけませんでした。ここから私は一人で物事を進めて行く大変さというものを学ぶことができたと感じています。</p>
<p>最後になりますがセミナーを受講した感想を書きたいと思います。</p>
<p>正直私はこのセミナーが第一希望ではなく配属された当初はあまりモチベーションが高くありませんでした。しかし、セミナー内でのディスカッションやＩＶＲＣやＩＶＲ展、日本未来館に行くなど様々な課外活動を通し自分にとって新しい発見がいくつもありました。</p>
<p>モチベーションが低い自分がいることを内心快く思っていなかった人もいるかもしれませんが、この約3ヶ月付き合ってくださりありがとうございました。私はとても充実した3ヶ月を過ごせたと感じています。<br />
ここでの経験を生かし更に自分を高めることができるようこれからも精進して行きたいと考えております。</p>
<p>最後にＩＶＲＣやセミナーについて相談に乗っていただいた先輩方および先生に感謝を、一緒にセミナーを受け苦楽をともにしたメンバーに感謝を述べたいと思います。</p>
<p>この約3ヶ月間、迷惑を掛けたりもしましたがここまでお付き合いいただきありがとうございました。</p>
<p>&nbsp;</p>
]]></content:encoded>
										</item>
		<item>
		<title>プログラミングができない大学3年生がオンラインゲーム作りに挑戦する。</title>
		<link>http://blog.shirai.la/semi2015a/1323133_0729/</link>
				<pubDate>Wed, 29 Jul 2015 03:38:13 +0000</pubDate>
		<dc:creator><![CDATA[s1323133]]></dc:creator>
				<category><![CDATA[セミナー]]></category>
		<category><![CDATA[1323133]]></category>
		<category><![CDATA[オンラインゲーム]]></category>
		<category><![CDATA[課題]]></category>

		<guid isPermaLink="false">http://blog.shirai.la/semi2015a/?p=358</guid>
				<description><![CDATA[こんにちは、神奈川工科大学情報学部情報メディア科3年の齊藤です。今回私はUnityを使ったオンラインゲームの開 &#8230; <a href="http://blog.shirai.la/semi2015a/1323133_0729/" class="more-link">続きを読む <span class="screen-reader-text">プログラミングができない大学3年生がオンラインゲーム作りに挑戦する。</span></a>]]></description>
								<content:encoded><![CDATA[<p>こんにちは、神奈川工科大学情報学部情報メディア科3年の齊藤です。今回私はUnityを使ったオンラインゲームの開発に挑戦したいと考え行動しました。<br />
そして私は私と同じようにオンラインゲームに興味を持ち作りたいと考えている人たちの助けになるようにと私が参考にした本と自分が行った流れをこのブログに載せていこうと考えました。</p>
<p>私が使った本は河田匡稔著の「オンラインゲームのしくみ Unityで覚えるネットワークプログラミング」という本です。<br />
本の内容に触れる前に一つ注意事項があります。<br />
この本はタイトルにある通りUnityを使って様々なサンプルを実行するためUnityのインストールが必須になりますのでご注意ください。<br />
以下この本を書いてくれた著者に感謝して記事を書いて行きます。</p>
<p>1章ではオンラインゲームを作るうえで考えていかなくてはいけないことやオンラインゲームならではの考え方などが載っています。正直なところ速くサンプルを使ってみたいという人たちからすると読み飛ばしたくなる場所ではあるかもしれないですが、個人的には軽くでもいいから一通り眼を通すべき場所だと思いました。<br />
前知識なしで飛ばしてしまおうと考えた人でも1.3は確実に読んでもらいたいと感じました、個々では本書を読み進めるにあたってというタイトルで本の構成やサンプル、用語についてと、あるので本書を読み進める上で助けになります。</p>
<p>2章では通信プログラムの基礎知識というタイトルで通信の仕組みについてや送受信プロトコルであるTCPとUDPの違いなど、通信についての基礎知識の紹介になります。<br />
TCPとUDPについて知っているからといってこの部分を全て飛ばさないでほしいと私は考えます。この章では基礎的な部分に加えオンラインゲームでよく使われるプロトコルや通信の遅延に対しどのように考えるべきかが書かれています。</p>
<p>3章から待ちに待ったサンプルプログラムを使用した演習になって行きます。3章ではソケットプログラムを用いたデータの送受信のサンプルを使います。</p>
<p>実行画面は以下のもののように非常に地味なものであります</p>
<p><a href="http://blog.shirai.la/semi2015a/files/2015/07/サンプル実行画面.png"><img class="  wp-image-360 aligncenter" src="http://blog.shirai.la/semi2015a/files/2015/07/サンプル実行画面-300x232.png" alt="サンプル実行画面" width="413" height="319" srcset="http://blog.shirai.la/semi2015a/files/2015/07/サンプル実行画面-300x232.png 300w, http://blog.shirai.la/semi2015a/files/2015/07/サンプル実行画面-1024x791.png 1024w, http://blog.shirai.la/semi2015a/files/2015/07/サンプル実行画面.png 1033w" sizes="(max-width: 413px) 100vw, 413px" /></a></p>
<p>空白の部分に相手のＩＰアドレスかあるいはローカルホストでテストを行うならばlocalhostと入力して自分をサーバーとして動かすか、サーバーに接続するかを選択します。<br />
相手との接続が成功していればサンプルが入っているファイルのbinフォルダの中にあるＴＣＰを使ったサンプルのほうならばSocketSampleTCP_Dataを開いてＵＤＰならばsocketSampleUDP_Dataを開く、そうすると中にoutput_log.txtができておりこれが通信の履歴になります。</p>
<p>ここからプログラムの解説を行いたいと思います。<br />
まずはじめに待ち受けようのソケットの生成を行います。</p>
<pre>// 待ち受け開始.
void StartListener()
{
Debug.Log("Start server communication.");

// ソケットを生成します.
m_listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
// 使用するポート番号を割り当てます.
m_listener.Bind(new IPEndPoint(IPAddress.Any, m_port));
// 待ち受けを開始します.
m_listener.Listen(1);

m_state = State.AcceptClient;
}
</pre>
<p>こちらにm_listenerと言う変数がありますね？こちらが待ち受けを行う専門のソケットでリスニングソケットと呼ばれるものです。<br />
そしてそのすぐ下の部分でソケットの種類をStreamと選択しプロトコルをＴＣＰと指定しています。その次にm_listenerにポート番号を割り当てます。そして最後に待ち受け状態にするためにListen関数を呼び出します。</p>
<p>次にクライアントからの接続要求受付についてです。</p>
<pre>// クライアントからの接続待ち.
void AcceptClient()
{
if (m_listener != null &amp;&amp; m_listener.Poll(0, SelectMode.SelectRead)) {
// クライアントから接続されました.
m_socket = m_listener.Accept();
Debug.Log("[TCP]Connected from client.");
m_state = State.ServerCommunication;
}
}
</pre>
<p>サーバーはクライアントからの接続要求の受付を行うためにこちらのAccept関数を呼び出します。この関数はクライアントからの接続要求があるまで処理をブロッキングします。<br />
ブロッキングとは呼び出した関数の処理が完了するまで処理の制御が帰ってこないようにすることです。<br />
しかしこのままだとゲームを作る際にブロッキングされてしまうとゲームとして成り立たなくなってしまうためPoll関数でクライアントからのデータ受信を監視して、データを受信したときだけACcept関数を呼び出すようにします。<br />
Poll関数とは複数のファイルディスクリプタを監視、制御するものである。<br />
ファイルディスクリプタで処理を待ち合わせるシステムコールを実行すると、データが到着するなどの一連の処理が完了するまでシステムコールから処理制御がリターンされなくなります。</p>
<p>次にサーバーへの接続、メッセージの送信、通信の切断の説明です。</p>
<pre>void ClientProcess()
{
Debug.Log("[TCP]Start client communication.");

// サーバへ接続.
m_socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp); ・・・①
m_socket.NoDelay = true;　・・・②
m_socket.SendBufferSize = 0;
m_socket.Connect(m_address, m_port);　・・・③

// メッセージ送信.
byte[] buffer = System.Text.Encoding.UTF8.GetBytes("Hello, this is client.");
m_socket.Send(buffer, buffer.Length, SocketFlags.None);

// 切断.
m_socket.Shutdown(SocketShutdown.Both);
m_socket.Close();

Debug.Log("[TCP]End client communication.");
}
</pre>
<p>サーバーとの接続を行うためのソケットの生成を行います。<br />
m_soketにsoketクラスのインスタンスを生成します。これが①の部分です。次に小さなパケットをバッファリングしないようにSoket.NoDelayプロパティをtureにsoket.SendBufferSizeの値を0に設定する、これが②の部分です。最後にm_soketに接続先のIPアドレスとポート番号を指定して接続要求を行います、これが③の部分になります。</p>
<p>ソケットの送受信にはSend関数とReceive関数を使ってデータの送受信をすることができます。この２つの関数はペアで扱われる関数であり、Send関数で送ったデータをReceive関数を呼び出すことによってデータを取り出すことができるようになっています。</p>
<p>最後に切断についてです。通信を終了させるときはShutdown関数を使用してパケットの送受信を遮断します、そしてClose関数を使用して通信の切断を行います。</p>
<pre>// 待ち受け終了.
void StopListener()
{
// 待ち受けを終了します.
if (m_listener != null) {
m_listener.Close();
m_listener = null;
}

m_state = State.Endcommunication;

Debug.Log("[TCP]End server communication.");
}
</pre>
<p>お互いに送信したデータを全て受け取ってから通信を終了させる場合は、Shutdown関数で送信だけ終了させて、全ての受信が終了してからClose関数を呼び出して終了します。</p>
<p>サーバーの待ち受けを終了する場合は、リスニングソケットを、Close関数を呼び出して破棄します。</p>
<p>UDPのソケットプログラミングではTCPと違い接続処理を行わずに通信することができる。なので待ち受けを行う必要がありません。<br />
UDPの送信、受信ではSendTo関数とReceiveFrom関数を使用します。TCPのほうで使われていたSend関数とReceive関数と同じようにこの二つの関数はペアで扱われる関数でありUDP通信時（コネクションレス型のデータ送信時）にデータ送受信を行う関数です。<br />
UDPでのポート番号の割り当てを行って通信可能になるまでのプログラムを以下に示します。</p>
<pre>void SendMessage()
{
Debug.Log("[UDP]Start communication.");

// サーバへ接続.
m_socket = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp);

// メッセージ送信.
byte[] buffer = System.Text.Encoding.UTF8.GetBytes("Hello, this is client.");
IPEndPoint endpoint = new IPEndPoint(IPAddress.Parse(m_address), m_port);
m_socket.SendTo(buffer, buffer.Length, SocketFlags.None, endpoint);

// 切断.
m_socket.Shutdown(SocketShutdown.Both);
m_socket.Close();

m_state = State.Endcommunication;

Debug.Log("[UDP]End communication.");
}
</pre>
<p>このように接続の処理がないだけでソースがかなり短くなります。</p>
<p>&nbsp;</p>
<p>次に４章のチャットプログラムについての解説をします。チャットプログラムを作る際考えておくべきことがあります。それは会話の流れです。相手が送っている間自分が入力できないなんて仕様だと会話として成り立たなくなってしまいます。他にもチャットを打ち込んだはずなのに相手に届いていないという事態になってしまっても会話が成り立ちません。なので相手に確実にデータを届け、かつ相手とのデータのやり取りで片方が待たなくてはいけないという状況を作らないようにしなくてはいけません。</p>
<p>このプログラムは確実にデータを届けるためTCP通信を使います。なので通信ライブラリ、TransportTCPクラスを使用を使用して作成されています。<br />
チャットプログラムはプレイヤーが自分でルームを作るか参加するかを選択するシーケンスと実際にチャットを行うシーケンスの２つで作られます。</p>
<p><a href="http://blog.shirai.la/semi2015a/files/2015/07/チャット.png"><img class="  wp-image-469 aligncenter" src="http://blog.shirai.la/semi2015a/files/2015/07/チャット-300x123.png" alt="チャット" width="600 height=" srcset="http://blog.shirai.la/semi2015a/files/2015/07/チャット-300x123.png 300w, http://blog.shirai.la/semi2015a/files/2015/07/チャット-1024x421.png 1024w, http://blog.shirai.la/semi2015a/files/2015/07/チャット.png 1548w" sizes="(max-width: 300px) 100vw, 300px" /></a></p>
<p>はじめにチャットルームの選択を行う処理のソースについてです。</p>
<pre>void SelectHostTypeGUI()
{
float sx = 800.0f;
float sy = 600.0f;
float px = sx * 0.5f - 100.0f;
float py = sy * 0.75f;

if (GUI.Button(new Rect(px, py, 200, 30), "チャットルームの作成")) {

m_transport.StartServer(m_port, 1);

m_state = ChatState.CHATTING;
m_isServer = true;
}


Rect labelRect = new Rect(px, py + 80, 200, 30);
GUIStyle style = new GUIStyle();
style.fontStyle = FontStyle.Bold;
style.normal.textColor = Color.white;
GUI.Label(labelRect, "あいてのIPあどれす", style);
labelRect.y -= 2;
style.fontStyle = FontStyle.Normal;
style.normal.textColor = Color.black;
GUI.Label(labelRect, "あいてのIPアドレス", style);

Rect textRect = new Rect(px, py + 100, 200, 30);
m_hostAddress = GUI.TextField(textRect, m_hostAddress);


if (GUI.Button(new Rect(px, py + 40, 200, 30), "チャットルームへの参加")) {
bool ret = m_transport.Connect(m_hostAddress, m_port);
if (ret) {
m_state = ChatState.CHATTING;
}
else {
m_state = ChatState.ERROR;
}
}
}
</pre>
<p>この部分でサーバーとなるかクライアントを選ぶかで接続の方法を変えています。サーバーとして部屋を作るボタンを選択すると３章であったようにStartSeaver関数を呼び出し待ち受け状態になり相手からの接続を待ちます。<br />
既存のサーバーに接続する際はテキストに記入された相手のIPを読み取りそのIPアドレスに接続します。サーバーに接続できればチャットに移行し、接続に失敗すると再度チャットルームの選択に戻ります。</p>
<p>次にチャットルームでのメッセージのやり取りの部分になります。</p>
<pre>enum ChatState {
HOST_TYPE_SELECT = 0,    // ルーム選択.
CHATTING,                // チャット中.
LEAVE,                    // 退出.
ERROR,                    // エラー.
};

 

void Update()
{
switch (m_state) {
case ChatState.HOST_TYPE_SELECT:
for (int i = 0; i &lt; CHAT_MEMBER_NUM; ++i) {
m_message[i].Clear();
}
break;

case ChatState.CHATTING:
UpdateChatting();
break;

case ChatState.LEAVE:
UpdateLeave();
break;
}
}


void UpdateChatting()
    {
        byte[] buffer = new byte[1400];

        int recvSize = m_transport.Receive(ref buffer, buffer.Length);
        if (recvSize &gt; 0) {
            string message = System.Text.Encoding.UTF8.GetString(buffer);
            Debug.Log("Recv data:" + message );
            m_chatMessage += message + "   ";// + "\n";

            int id = (m_isServer == true)? 1 : 0;
            AddMessage(ref m_message[id], message);
        }    
    }
    
</pre>
<p>Update部分はチャットを退出するまで繰り返すというものである。<br />
UpdateChatting関数は送受信するメッセージをキャラクターごとのバッファに保存されます。このバッファはm_messageに保管されています。</p>
<p>次にチャットの送受信を行う部分のソースについてです。</p>
<pre>void ChattingGUI()
{
Rect commentRect = new Rect(220, 450, 300, 30);
m_sendComment = GUI.TextField(commentRect, m_sendComment, 15);

bool isSent = GUI.Button(new Rect (530, 450, 100, 30), "しゃべる");
if (Event.current.isKey &amp;&amp;
Event.current.keyCode == KeyCode.Return) {
if (m_sendComment == m_prevComment) {
isSent = true;
m_prevComment = "";
}
else {
m_prevComment = m_sendComment;
}
}


if (isSent == true) {
string message = "[" + DateTime.Now.ToString("HH:mm:ss") + "] " + m_sendComment;
byte[] buffer = System.Text.Encoding.UTF8.GetBytes(message);
m_transport.Send(buffer, buffer.Length);
AddMessage(ref m_message[(m_isServer == true)? 0 : 1], message);
m_sendComment = "";
}


if (GUI.Button (new Rect (700, 560, 80, 30), "退出")) {
m_state = ChatState.LEAVE;
}


// とうふやさん(サーバ側)のメッセージ表示.
if (m_transport.IsServer() ||
m_transport.IsServer() == false &amp;&amp; m_transport.IsConnected()) {
DispBalloon(ref m_message[0], new Vector2(200.0f, 200.0f), new Vector2(340.0f, 360.0f), Color.cyan, true);
GUI.DrawTexture(new Rect(50.0f, 370.0f, 145.0f, 200.0f), this.texture_tofu);
}

if (m_transport.IsServer() == false ||
m_transport.IsServer() &amp;&amp; m_transport.IsConnected()) {
// だいずやさんの(クライアント側)のメッセージ表示.
DispBalloon(ref m_message[1], new Vector2(600.0f, 200.0f), new Vector2(340.0f, 360.0f), Color.green, false);
GUI.DrawTexture(new Rect(600.0f, 370.0f, 145.0f, 200.0f), this.texture_daizu);
}
}
</pre>
<p>この部分には３つの処理が存在しており１つ目が相手にメッセージを送るもの、２つ目に退出ボタンが押されているかの監視をして押されたときに退出処理をするものです。３つ目にメッセージを受信してそれを表示するものです。</p>
<p>最後に通信を切断行う部分についてです。</p>
<pre>void UpdateLeave()
{
if (m_isServer == true) {
m_transport.StopServer();
}
else {
m_transport.Disconnect();
}

// メッセージの削除.
for (int i = 0; i &lt; 2; ++i) {
m_message[i].Clear();
}

m_state = ChatState.HOST_TYPE_SELECT;
}
</pre>
<p>次に５章のターン製ゲームについてです。<br />
サンプルでは３目並べのゲームを制作して行きます。<br />
こちらのゲームはチャットプログラムのように好きなときに操作できてしまうとゲームとして成り立たなくなってしまいます。<br />
なので相手の操作が終わるまで自分の操作ができないようにする必要があります。しかしそうするといつまでも相手が時間を掛けてしまうとゲームのテンポが非常に悪くなってしまいます。<br />
上記の点について考えてゲームデザインを設計して行かなければいけません<br />
ソースについて書いて行きます。</p>
<p>はじめに自分のターンかを判定する部分です</p>
<pre>public class TicTacToe : MonoBehaviour {

// ターン種別.
private enum Turn {
Own = 0,        // 自分のターン.
Opponent,        // 相手のターン.
};

// 現在のターン.
private Mark            turn;

// ローカルのマーク.
private Mark            localMark;

// リモートのマーク.
private Mark            remoteMark;
</pre>
<p>ここでは自分がマークを置く順番かを判定しています。</p>
<p>次に全体のターンの処理の部分になります</p>
<pre>void UpdateTurn()
{
bool setMark = false;

if (turn == localMark) {
setMark = DoOwnTurn();

//置けない場所を押されたときは、クリック用のSEを鳴らします.
if (setMark == false &amp;&amp; Input.GetMouseButtonDown(0)) {
AudioSource audio = GetComponent&lt;AudioSource&gt;();
audio.clip = se_click;
audio.Play();
}
}
else {
setMark = DoOppnentTurn();

//置けないときに押されたときは、クリック用のSEを鳴らします.
if (Input.GetMouseButtonDown(0)) {
AudioSource audio = GetComponent&lt;AudioSource&gt;();
audio.clip = se_click;
audio.Play();
}
}

if (setMark == false) {
// 置き場を検討中です.
return;
}
else {
//マークが置かれたSEを鳴らします.
AudioSource audio = GetComponent&lt;AudioSource&gt;();
audio.clip = se_setMark;
audio.Play();
}

// マークの並びをチェックします.
winner = CheckInPlacingMarks();
if (winner != Winner.None) {
//勝ちの場合はSEを鳴らします.
if ((winner == Winner.Circle &amp;&amp; localMark == Mark.Circle)
|| (winner == Winner.Cross &amp;&amp; localMark == Mark.Cross)) {
AudioSource audio = GetComponent&lt;AudioSource&gt;();
audio.clip = se_win;
audio.Play();
}
//BGM再生終了.
GameObject bgm = GameObject.Find("BGM");
bgm.GetComponent&lt;AudioSource&gt;().Stop();

// ゲーム終了です.
progress = GameProgress.Result;
}

// ターンを更新します.
turn = (turn == Mark.Circle)? Mark.Cross : Mark.Circle;
timer = turnTime;
}
</pre>
<p>この処理では自分のターンであればマークを配置し、相手のターンであれば相手がマークを配置するのを待ちます。</p>
<p>次に自分のターンの処理についてです。</p>
<pre>// 自分のターンの時の処理.
bool DoOwnTurn()
{
int index = 0;

timer -= Time.deltaTime;
if (timer &lt;= 0.0f) {
// 時間切れ.
timer = 0.0f;
do {
index = UnityEngine.Random.Range(0, 8);
} while (spaces[index] != -1);
}
else {
// マウスの左ボタンの押下状態を監視します.
bool isClicked = Input.GetMouseButtonDown(0);
if (isClicked == false) {
// 押されていないのでなにもしません.
return false;
}

Vector3 pos = Input.mousePosition;
Debug.Log("POS:" + pos.x + ", " + pos.y + ", " + pos.z);

// 受信した情報から選択されたマスに変換します.
index = ConvertPositionToIndex(pos);
if (index &lt; 0) {
// 範囲外が選択されました.
return false;
}
}

// マスに目を置きます.
bool ret = SetMarkToSpace(index, localMark);
if (ret == false) {
// 置けない.
return false;
}

// 選択したマスの情報を送信します.
byte[] buffer = new byte[1];
buffer[0] = (byte)index;
m_transport.Send (buffer, buffer.Length);

return true;
}
</pre>
<p>自分のターンではマウンスからの入力を受け付け配置するマス番号を算出する処理、算出したマス番号にマークを配置する処理、配置したマス番号のデータを相手に送信する処理の３つで成り立っています。</p>
<p>次に相手の処理についてです。</p>
<pre>// 相手のターンの時の処理.
bool DoOppnentTurn()
{
// 相手の情報を受信します.
byte[] buffer = new byte[1];
int recvSize = m_transport.Receive(ref buffer, buffer.Length);

if (recvSize &lt;= 0) {
// まだ受信していません.
return false;
}

// サーバなら○クライアントなら×を指定します.
//Mark mark = (m_network.IsServer() == true)? Mark.Cross : Mark.Circle;

// 受信した情報から選択されたマスに変換します.
int index = (int) buffer[0];

Debug.Log("Recv:" + index + " [" + m_transport.IsServer() + "]");

// マスに目を置きます.
//bool ret = SetMarkToSpace(index, mark);
bool ret = SetMarkToSpace(index, remoteMark);
if (ret == false) {
// 置けない.
return false;
}
return true;
}
</pre>
<p>相手のターンでは相手から配置するマス番号の情報を受信する処理と受け取ったマス番号からマークを配置する処理の２つから成り立っています。</p>
<p>次にゲーム開始についての部分についてです。<br />
ここでゲームの初期化を行います</p>
<pre>// ゲーム開始.
public void GameStart()
{
// ゲーム開始の状態にします.
progress = GameProgress.Ready;

// サーバが先手になるように設定します.
turn = Mark.Circle;

// 自分と相手のマークを設定します.
if (m_transport.IsServer() == true) {
localMark = Mark.Circle;
remoteMark = Mark.Cross;
}
else {
localMark = Mark.Cross;
remoteMark = Mark.Circle;
}
</pre>
<p>最後にエラー処理についてです</p>
<pre>// イベント発生時のコールバック関数.
public void EventCallback(NetEventState state)
{
switch (state.type) {
case NetEventType.Disconnect:
if (progress &lt; GameProgress.Result &amp;&amp; isGameOver == false) {
progress = GameProgress.Disconnect;
}
break;
}
}
}
</pre>
<p>この部分は回線切断などのゲームに大きな影響を与えてしまう通信エラーが起こってしまったときに呼び出されます。そしてゲームのモードが切断状態のGame.Progress.Disconnectに変更されます。</p>
<p>現状自分ができたのはここまです。<br />
自分がここまでやるのにはおおよそ５時間くらいかかりました。<br />
サンプルの実行だけならば１時間も必要ないのですがそれの理解となると<br />
オフラインのものと違うところが多く時間がかかってしまいました。<br />
サンプルはネットで配布されているのでそれをダウンロードすれば実行結果もソースもすぐに見ることができます。良ければ本も見ていただければ幸いです。</p>
<p>オンラインゲームを作ろうとしている人の助けになっていれば幸いです。</p>
<p>参考文献<br />
・オンラインゲームのしくみ<br />
「Unityで覚えるネットワークプログラミング」</p>
<p>&nbsp;</p>
]]></content:encoded>
										</item>
		<item>
		<title>ソロでIVR展見学に行った</title>
		<link>http://blog.shirai.la/semi2015a/s1323133ivrc/</link>
				<pubDate>Sun, 28 Jun 2015 02:37:40 +0000</pubDate>
		<dc:creator><![CDATA[s1323133]]></dc:creator>
				<category><![CDATA[訪問記]]></category>
		<category><![CDATA[IVR展]]></category>
		<category><![CDATA[セミナー]]></category>

		<guid isPermaLink="false">http://blog.shirai.la/semi2015a/?p=149</guid>
				<description><![CDATA[私本日IVR展に行ってまいりました。 自分がついたのが16時だったので2時間しか見学が出来ませんでしたがとても &#8230; <a href="http://blog.shirai.la/semi2015a/s1323133ivrc/" class="more-link">続きを読む <span class="screen-reader-text">ソロでIVR展見学に行った</span></a>]]></description>
								<content:encoded><![CDATA[<p>私本日IVR展に行ってまいりました。</p>
<p>自分がついたのが16時だったので2時間しか見学が出来ませんでしたがとても参考になる話が多い2時間だったと感じています。</p>
<p>私が見た企業のVR作品の中で私がオススメしたいと感じたものがありました。</p>
<p>いくつかあったVRのなかで積木製作さんのOculus Riftを使ったVR作品がオススメしたいと感じました。</p>
<figure id="attachment_151" aria-describedby="caption-attachment-151" style="width: 300px" class="wp-caption alignnone"><a href="http://blog.shirai.la/semi2015a/files/2015/06/DSC_0205.jpg"><img class="size-medium wp-image-151" src="http://blog.shirai.la/semi2015a/files/2015/06/DSC_0205-300x169.jpg" alt="DSC_0205" width="300" height="169" srcset="http://blog.shirai.la/semi2015a/files/2015/06/DSC_0205-300x169.jpg 300w, http://blog.shirai.la/semi2015a/files/2015/06/DSC_0205-1024x576.jpg 1024w" sizes="(max-width: 300px) 100vw, 300px" /></a><figcaption id="caption-attachment-151" class="wp-caption-text">作品画像</figcaption></figure>
<p>非常にCGのクオリティが高く見ごたえがある作品でCGの作成にはUnityを使っているとの事でUnityでもここまでのクオリティのものが作れると知りとても驚きました。</p>
<p>他にもIVRのところにドローンを使用した技術を出展している企業が3社ほどあり驚きました。</p>
<p>今回IVR展に行き自分たちが提出した企画書のないように似た作品を見つけたおかげで、その作品との差別化や対象年齢などの設定を自分の中でまとめることができました。</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
]]></content:encoded>
										</item>
		<item>
		<title>齊藤弘朗　IVRC調査結果</title>
		<link>http://blog.shirai.la/semi2015a/ivrc20150513/</link>
				<pubDate>Wed, 13 May 2015 13:50:06 +0000</pubDate>
		<dc:creator><![CDATA[s1323133]]></dc:creator>
				<category><![CDATA[課題]]></category>
		<category><![CDATA[IVRC]]></category>
		<category><![CDATA[s1323133]]></category>
		<category><![CDATA[白井研究室セミナー]]></category>
		<category><![CDATA[齊藤弘朗]]></category>

		<guid isPermaLink="false">http://blog.shirai.la/semi2015a/?p=33</guid>
				<description><![CDATA[IVRC2015の審査方針に従って自分の作品の新規性や体験面のインパクトなどについて検討する １３２３１３３　 &#8230; <a href="http://blog.shirai.la/semi2015a/ivrc20150513/" class="more-link">続きを読む <span class="screen-reader-text">齊藤弘朗　IVRC調査結果</span></a>]]></description>
								<content:encoded><![CDATA[<p>IVRC2015の審査方針に従って自分の作品の新規性や体験面のインパクトなどについて検討する</p>
<p>１３２３１３３　齊藤弘朗</p>
<p>・魔方陣を書いてみたい　→　特許検索ですでに多摩大学「MAHO －PEN」という作品で論文を発表済みであることを発見、新規性は無し</p>
<p><a href="http://ivrc.net/2008/recruit/abstract_maho-pen.pdf" target="_blank" rel="nofollow">ivrc.net/2008/recruit/abstract_maho-pen.pdf</a></p>
<p>・隕石を打ち返して星を破壊するゲーム　→　打ち返す系統のゲームは数多くあり新規性無し</p>
<p>・漢字の一部をひっぱったり伸ばしたり消したりして正しい漢字にする　→　特許検索では自分の想定しているようなものは見当たらなかったが文字をいじるゲームがいくつかある漢字の一部を動かすだけでは体験してみたいというインパクトにかけているように感じる。</p>
<p>・ボールになりたい　→　物や動物にカメラをつけてその視点を体験するというものは様々な人が実行しており視点だけだとありきたりで新規性もなく体験してみたいというインパクトにかけている。</p>
<p>・モーションセンサを使ってオンラインでサバゲ　→　すでに「ＰｒｉｏＶＲ」というものが実現されており新規性なし</p>
<p>作品ＵＲＬ：http://gigazine.net/news/20140218-priovr-suit-up-game/</p>
<p><figure id="attachment_54" aria-describedby="caption-attachment-54" style="width: 300px" class="wp-caption alignnone"><a href="http://blog.shirai.la/semi2015a/files/2015/05/画像１.jpg"><img class="size-medium wp-image-54" src="http://blog.shirai.la/semi2015a/files/2015/05/画像１-300x169.jpg" alt="画像１" width="300" height="169" srcset="http://blog.shirai.la/semi2015a/files/2015/05/画像１-300x169.jpg 300w, http://blog.shirai.la/semi2015a/files/2015/05/画像１.jpg 640w" sizes="(max-width: 300px) 100vw, 300px" /></a><figcaption id="caption-attachment-54" class="wp-caption-text">画像１</figcaption></figure>画像引用元：http://gigazine.net/news/20140218-priovr-suit-up-game/</p>
<p>・恐竜にのってレース　→　レースゲーム自体が数多く出ており其の時点で新規性にかけている。</p>
<p>・巨人になる　→　巨人のドシンなど巨人をモチーフにしたゲームはいくつか存在していてそれをヘッドマウントディスプレイなどで再現すれば体験のインパクトはいくらかあると感じるが新規性が無い。</p>
<p>実際に調べてみると自分が考えた案の大半がすでに実現されているものが多くそうでないものも実際に自分がやってみると考えてみるとあまりにも面白くなさそうなものであり、新しいと面白いを両立させることがここまで難しいことだとは考えていませんでした。次はまず新規性という点に重点をおいて考えそこから出た案をどのようにすれば面白く技術的なものにできるかを考えていきたいと思っています。</p>
]]></content:encoded>
										</item>
	</channel>
</rss>
